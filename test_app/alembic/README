Generic single-database configuration.

1) alembic init alembic

2) set sqlalchemy.url in alembic.ini

3) import models in env.py (whole module! if we import just the Base part for metadata, it'll end up in no good;
as described here:
https://pawamoy.github.io/posts/add-alembic-migrations-to-existing-fastapi-ormar-project/
also look here:
https://stackoverflow.com/questions/26251094/alembic-sqlalchemy-initial-migration
with result described here in the next problem:
https://stackoverflow.com/questions/26275041/alembic-sqlalchemy-does-not-detect-existing-tables
)
and import MetaData
altogether in present case we get:
import models
target_metadata = models.Base.metadata

the target_metadata collection may also be defined as a sequence if an application has multiple metadata collections involved, e.g.:
import models1
import models2
target_metadata = [models1.Base.metadata, models2.Base.metadata]

the sequence of metadata collections will be consulted in order during the autogenerate process.
(!) each metadata must contain unique table keys (combination of table name and schema); if two metadata objects contain a table with the same schema/name combination, an error is raised


3.5) if the db consists of tables generated from different models
and in current migration we want autogenerate to consider only the tables that are defined in a current service (e.g. in migration for a specific service inside the whole app which uses a particular part of the database but does not define other tables, which may be generated in other parts of the app - i.e. other services)
- then we need to tell alembic to omit all tables that are not part of the current service

there are different types of omitting (see 'controlling what to be autogenerated' section in https://alembic.sqlalchemy.org/en/latest/autogenerate.html)

in our case we want to omitt all tables with names that are in the files which are not included to our target_metadata

to do so - in env.py, after defining target_metadata, add:

    def include_name(name, type_, parent_names):
        if type_ == "table":
            return name in target_metadata.tables
        else:
            return True

AND

further in env.py, in run_migrations_online/offline, in context.configure make sure the following lines to be present:

    target_metadata = target_metadata, #usually already present
    include_name = include_name,
    include_schemas = False

with that include_name hook the tables created from different parts of the app will be omitted


3.6) if we use any custom types of data, see 'Comparing and Rendering Types' section on https://alembic.sqlalchemy.org/en/latest/autogenerate.html

3.7) go to alembic.ini and uncomment the naming by date convention
file_template = %%(year)d_%%(month).2d_%%(day).2d_%%(hour).2d%%(minute).2d-%%(rev)s_%%(slug)s
(!) - important! - although revisions names will start with date and time now, we can only refer to revisions (for upgrade or downgrade issues) by starting typing the token part of the name, i.e. revisions can't be referred by date and time 


4) check whether your current db statement is fully up to models
to do so
make initial migration
if there's anything in upgrade or downgrade, that's bad, fix it
after fixing delete version and then drop alembic_version table in db
then repeat until initial migration returns pass in both upgrade and downgrade

5) if we want the initial migration to create a database in the statement in which we have it nowadays (which is up do date with the models, as we ensured on step 4), then we need a trick
- first, delete the initial migration we obtained on the previous step and drop the alembic_version table;
- second, make an empty db;
- third, substitute the address to an empty database in alembic.ini - sqlalchemy.url;
- fourth, make an initial migration;
  there you should have create tables and indicies in upgrade and drop in downgrade;
  if not like that - return to previous steps;
- fifth, change the db name in alembic.ini to actual one;
- run alembic stamp head (this will tell alembic that your current db is up to date with the initial revision you've made);
And now we have an up-to-date base, which is said to be generated from our initial revision.
That's it, do nothing else here, the bd is up-to-date, we don't need a new revision for it.
(checked with upgrading for second revision and then downgrading to the initial one: on the initial one we get the base in the current statement)

if however we want our database not to have a "generating" initial revision, then we just make the initial revision as it is in step 4.

6) whenever we make a migration - go to the migration file and alter it as needed, including adjustments to the directives as well as the addition of other directives which these may be dependent on - specifically data changes in between creates/alters/drops







NOTE ON AUTOGENERATE (from alembic docs: https://alembic.sqlalchemy.org/en/latest/autogenerate.html):

        Autogenerate will detect:

        Table additions, removals.
        Column additions, removals.
        Change of nullable status on columns.
        Basic changes in indexes and explicitly-named unique constraints
        Basic changes in foreign key constraints

        Autogenerate can optionally detect:

        Change of column type.
        Change of server default.

        Autogenerate can not detect:

        1) Changes of table name. These will come out as an add/drop of two different tables, and should be hand-edited into a name change instead.
        2) Changes of column name. Like table name changes, these are detected as a column add/drop pair, which is not at all the same as a name change.
        3) Anonymously named constraints. Give your constraints a name, e.g. UniqueConstraint('col1', 'col2', name="my_name"). See the section The Importance of Naming Constraints (https://alembic.sqlalchemy.org/en/latest/naming.html) for background on how to configure automatic naming schemes for constraints.
        4) Special SQLAlchemy types such as Enum when generated on a backend which doesn’t support ENUM directly - this because the representation of such a type in the non-supporting database, i.e. a CHAR+ CHECK constraint, could be any kind of CHAR+CHECK. For SQLAlchemy to determine that this is actually an ENUM would only be a guess, something that’s generally a bad idea. To implement your own “guessing” function here, use the sqlalchemy.events.DDLEvents.column_reflect() event to detect when a CHAR (or whatever the target type is) is reflected, and change it to an ENUM (or whatever type is desired) if it is known that that’s the intent of the type. The sqlalchemy.events.DDLEvents.after_parent_attach() can be used within the autogenerate process to intercept and un-attach unwanted CHECK constraints.
        5) Some free-standing constraint additions and removals may not be supported, including PRIMARY KEY, EXCLUDE, CHECK; these are not necessarily implemented within the autogenerate detection system and also may not be supported by the supporting SQLAlchemy dialect.
        6) Sequence additions, removals - not yet implemented.

        !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        the autogenerate process scans across all table objects within the database that is referred towards by the current database connection in use.

        so we have to add a feature to ignore tables from different parts of the database not affected by the current service - see step 3.5)
